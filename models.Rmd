---
title: "Models for preliminary report"
date: "14/07/2020"
output: pdf_document
---

```{r message=FALSE, warning=FALSE}
#Don't remove my libraries, I use them all. ada
library(tidyr)
library(caret)
library(dplyr)
library(lubridate)
library(corrplot)
library("pROC")
library(ggplot2)
library(RColorBrewer)
library(kableExtra)
library("arm")
library("car")
library("jtools")
library(pls)
library(glmnet)
library(MASS)
library("leaps")
library("CAST")
```

# Read Data 

1. Interations with LASSO and PSLR
2. Residual plots
3. Look at bad residuals
4. Poster
5. Predict number of campaings ???


```{r warning=FALSE, results="hide"}
kickstarter_min <- readRDS("final_clean_kickstarter.rds")
 
kickstarter_min$cat_child <- NULL
kickstarter_min$city <- NULL
kickstarter_min$blurb <- NULL
kickstarter_min$country_displayable_name <- NULL 
kickstarter_min$name <- NULL
kickstarter_min$deadline<-NULL 
kickstarter_min$launched_at<-NULL

#kickstarter_min$backers_count<- NULL #?
str(kickstarter_min)
```

```{r}
summary(kickstarter_min)
```


# change country to continent 
```{r warning=FALSE}
cntnt_Europe = c("DK","AT", "BE", "CH","DE","ES", "FR", "GB","IE", "IT","LU", "NL","NO","SE")
cntnt_Asia = c("HK","JP","SG")
cntnt_NA = c("US","CA")
cntnt_SA = c("MX")
cntnt_Pacific = c("NZ","NZ")
#cntnt_NAmer =

eurpn <- kickstarter_min$country %in% cntnt_Europe
asian <- kickstarter_min$country %in% cntnt_Asia  
na <- kickstarter_min$country %in% cntnt_NA
sa <- kickstarter_min$country %in% cntnt_SA
pacific <- kickstarter_min$country %in% cntnt_Pacific

kickstarter_min$continent = "ph"
kickstarter_min$continent <- kickstarter_min$continent[eurpn] <- "Europe"
kickstarter_min$continent[asian] <- "Asia"
kickstarter_min$continent[na] <- "NorthAmerica"
kickstarter_min$continent[sa] <- "SouthAmerica"
kickstarter_min$continent[pacific] <- "Pacific"

kickstarter_min$continent <- as.factor(kickstarter_min$continent) # obvisouly needs to be a factor.....
kickstarter_min$country <- NULL
```


```{r}
str(kickstarter_min)
```


```{r}
summary(kickstarter_min)
```


# Split into train and test 
```{r}
set.seed(456) 
SplitIndex <- sample(x = c("Train", "Test"), replace = T, prob = c(0.8,0.2), 
                     size = nrow(kickstarter_min))

#Subset data into a train and test set based on the SplitIndex vector
traindata <- kickstarter_min[SplitIndex == "Train", ]
testdata <- kickstarter_min[SplitIndex == "Test", ]
```

# Data for predicting Goal Ratio
This allows us to create the interactions with * instead of writting them all out. 

```{r}
traindata2 <- traindata
traindata2$pledged <- NULL
traindata2$goal <- NULL
traindata2$pledged_log <-NULL
traindata2$id <- NULL
traindata2$target <- NULL
```


```{r}
summary(traindata2)
```

## Vairables in the Model

```{r}
str(traindata2)
```

# Variable selection and Modeling

## Test Every Interaction
Lets use Foward, Backward, PLS, and LASSO to build models!!! With every interaction. This should be FUN!!!

Lets test every interaction with forward.
```{r}
fwd_step <- NULL
if (!file.exists("fwd_step.rds")){
  lm_model <- lm(goal_ratio~.*., traindata2)
  fwd_step <- step(lm_model, direction="forward", k=log(nobs(lm_model)))
  saveRDS(fwd_step, file="fwd_step.rds")
}else{
  fwd_step <- readRDS(file="fwd_step.rds")
}

bck_step <- NULL
if (!file.exists("bck_step.rds")){
  lm_model <- lm(goal_ratio~.*., traindata2)
  bck_step <- step(lm_model, direction="backward", k=log(nobs(lm_model)))
  saveRDS(bck_step, file="bck_step.rds")
}else{
  bck_step <- readRDS(file="bck_step.rds")
}

pls <- NULL
if (!file.exists("pls.rds")){
  pls <- plsr(goal_ratio~.*., data = traindata2, validation="CV", k=5,ncomp=7)
  saveRDS(pls, file="pls.rds")
}else{
  pls <- readRDS(file="pls.rds")
}

lasso <- NULL
if (!file.exists("lasso.rds")){
  lasso <- cv.glmnet(model.matrix(goal_ratio~.*., data = traindata2)[, -1],
  traindata$goal_ratio,
  alpha = 1, k = 5, labmda = 10^seq(100, -2, length = 10000))
  saveRDS(lasso, file="lasso.rds")
}else{
  lasso <- readRDS(file="lasso.rds")
}

```

```{r}
plot(bck_step)
```

```{r}
plot(lasso)
```

```{r}
predict(lasso,type="coefficients",s=lasso$lambda.1se)
```


```{r}
bck_step
```


```{r}
plot(fwd_step)
```


## Best subset with AIC
Best step using AIC in direction "Backward". These are the default arguments.

```{r warning=FALSE, results="hide"}
#traindata$goal_ratio[traindata$goal_ratio <= 4] <- 4
lm_model <- lm(goal_ratio~.-pledged-goal-pledged_log-id-target, traindata)
best_step <- step(lm_model, direction="both", k=log(nobs(lm_model)))
```

Lets print out the best AIC model using Both directionial search
```{r}
best_step
```

## PLS

```{r}
pls <- plsr(goal_ratio~.*., data = traindata2, validation="CV", k=5,ncomp=7)
validationplot(pls,val.type="RMSEP")
```
```{r}
pls$loadings
```



## Lasso 

```{r}
lasso <- cv.glmnet(model.matrix(goal_ratio~.*., data = traindata)[, -1],
  traindata$goal_ratio,
  alpha = 1, k = 10, labmda = 10^seq(100, -2, length = 10000)
)
plot(lasso)
```

```{r}
predict(lasso,type="coefficients",s=lasso$lambda.min)
```




#Residual plot of best step

**TO-DO** Residual plot for LASSO and PLS

```{r}
plot(best_step)
```

```{r}
traindata$res <- best_step$residuals
```

```{r}
traindata[traindata$res > 100]
```



##Lets try Gamma Distribution

PREDICTING GOAL_RATIO
This is creating issues because Gamma can not take negative numbers or 0. So goal ratios or pledged of 0 need to be converted. If its too small Log as link function does not handle it well. 

The inverse and identity link function gives the error "Error: no valid set of coefficients has been found: please supply starting values"

PREDICTING PLEDGED
When predicting pledged, it worked better with goal and without goal_log.


**IMPORTANT** 0 values not allowed for gamma. Lets make them = 0.01


```{r warning=FALSE, results="hide"}
traindataGAMMA <- traindata
traindataGAMMA$pledged[traindataGAMMA$pledged == 0] <- .01
gmod<-glm(pledged~.-goal_ratio-goal_log-pledged_log-id-target-backers_count,family=Gamma(link=identity),traindataGAMMA)
gstep<-step(gmod,trace=FALSE)
gstep
```


**QUESTION** - When using pearson residuals, are they suppose to be random
```{r}
plot(residuals(gstep,"pearson")~fitted(gstep),pch=16)
```


#Binominal model 


##Baseline model with goal  
```{r}
binominal_baseline <- glm(target ~ backers_count +
                            cat_parent  +
                            month + goal + staff_pick  +
                            number_of_days + blurb_length +
                            name_length , data = traindata, family = binomial)
```


##Model accuracy, precision, sensitivity, 
```{r warning=FALSE}
confusionStats_df <- function(df,target){ # is as.character needed?
  cm <- confusionMatrix(table(Actual = df[[target]],Predicted = df$ClassPredict))
  return(data.frame(cbind(t(cm$overall),t(cm$byClass))))
}

predictLog <- function(df,log, thresh=0.5, t=T, f=F){
    
  p           <- predict(object = log, newdata = df,
                            type = "response",se.fit=T)
  df$fit      <- p$fit
  df$se.fit   <- p$se.fit
  df$logits   <- predict(object = log, newdata = df)
  df$ClassPredict <- ifelse(df$fit > thresh, t, f)
  return(df)
}

results <- predictLog(testdata, binominal_baseline, t="successful", f="failed")

results$ClassPredict <- as.factor(results$ClassPredict)

confusionStats_df(results,"target")[c("Accuracy","Sensitivity","Specificity","Precision")]

kable(confusionStats_df(results,"target")[c("Accuracy","Sensitivity","Specificity","Precision")]* 100, digits = 2, caption = "Model performance in percentage", booktabs = TRUE) %>%
  kable_styling(font_size = 10, full_width = F)%>%
  kable_styling(bootstrap_options = c("striped", "scale_down", "hover", "condensed")) 



```




##ROC 
```{r warning=FALSE}
plot.roc(results$target,results$fit, col = "royalblue4", backgroundcol = "lightskyblue",
         main = "Binominal baseline model", print.auc = TRUE)
```

##Residual plot 

```{r}
binnedplot(results$fit, as.numeric(results$target) - as.numeric(results$ClassPredict), col.pts = "royalblue4", col.int = "lightskyblue")
```


